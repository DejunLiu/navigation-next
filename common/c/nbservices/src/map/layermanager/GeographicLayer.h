/*
Copyright (c) 2018, TeleCommunication Systems, Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
   * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the TeleCommunication Systems, Inc., nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED. IN NO EVENT SHALL TELECOMMUNICATION SYSTEMS, INC.BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*!--------------------------------------------------------------------------
   @file         GeographicLayer.h
   @defgroup     nbmap
*/
/*
    (C) Copyright 2013 by TeleCommunications Systems, Inc.

   The information contained herein is confidential, proprietary to
   TeleCommunication Systems, Inc., and considered a trade secret as defined
   in section 499C of the penal code of the State of California. Use of this
   information by anyone other than authorized employees of TeleCommunication
   Systems is granted only under a written non-disclosure agreement, expressly
   prescribing the scope and manner of such use.
--------------------------------------------------------------------------*/

/*! @{ */
#ifndef _GEOGRAPHICLAYER_H_
#define _GEOGRAPHICLAYER_H_

#include "UnifiedLayer.h"
#include "GeoPolyline.h"
#include "ExternalMaterial.h"

namespace nbmap
{

typedef enum _GeographicUpdateType
{
    GUT_None,                 /*!< No further processing required. */
    GUT_Reload,               /*!< Needs to Refresh tiles of this layer */
    GUT_Refresh,              /*!< Just reload, don't need to regenerate */
} GeographicUpdateType;

class GeographicLayerListener
{
public:
    virtual ~GeographicLayerListener(){};

    /*! Notify listener that graphic is updated. */
    virtual void GeographicUpdated(Geographic*, GeographicUpdateType) = 0;
    virtual void GeographicToggled(Geographic*) = 0;
    /*! Notify listener to add/remove/active Material.  */
    virtual void MaterialAdded(ExternalMaterialPtr material)   = 0;
    virtual void MaterialRemoved(ExternalMaterialPtr material) = 0;
    virtual void MaterialActivate(ExternalMaterialPtr material) = 0;
};

class GeographicTileGenerator
{
public:
    GeographicTileGenerator(const shared_ptr<const string>& category)
            : m_materialCategory(category) {}
    virtual ~GeographicTileGenerator() {}

    /*! Resets this generator.

      @return None.
    */
    virtual void Reset() = 0;

    /*! Get materials used by tile generated by this generator.

       @return None.
    */
    virtual void GetMaterials(vector<ExternalMaterialPtr>& materials) const = 0;

    /*! Generate tile data for given tile key.

        @return NE_OK if succceed.
    */
    virtual NB_Error GenerateTileData(const TileKeyPtr& key,
                                      shared_ptr<nbcommon::DataStream>& data) = 0;
protected:
    shared_ptr<const string> m_materialCategory;
};

/*! Base class for new Geographic layer. */
class GeographicLayer : public UnifiedLayer
{
public:
    GeographicLayer(shared_ptr<string> layerId,
                    uint32 layerIdDigital,
                    NB_Context* context,
                    GeographicLayerListener* listener = NULL);
    virtual ~GeographicLayer();

    /*! Callback for graphics to tell GeographicLayer update layer.

        Internally, this function will perform task switching and then call
        ProcessUpdateGraphic() and PostGraphicUpdated() in proper thread.
     */
    void GraphicUpdated(Geographic* graphic);
    void UnregisterListener();
    void GraphicEnabled(Geographic* graphic, bool enabled);

    virtual std::string className() const { return "GeographicLayer"; }

protected:
    GeographicLayerListener* m_listener;
    uint32                   m_currentSubDraworder;

private:
    /*! Function scheduled to be executed after switching to CCC thread.   */
    static void CCC_UpdateGraphic(PAL_Instance* pal, void* userData);
    static void CCC_ToggleGraphic(PAL_Instance* pal, void* userData);

    /*! Process updated graphic.

        Derived class should implement this function to do jobs of their own.
    */
    virtual GeographicUpdateType ProcessUpdatedGraphic(Geographic* graphic) = 0;

    /*! Process necessary clean ups after graphic updated.

       Derived class should implement this function to do jobs of their own.
    */
    virtual void PostGraphicUpdated(Geographic* graphic) = 0;

    shared_ptr<bool> m_isValid;
};

typedef shared_ptr<GeographicLayer> GeographicLayerPtr;

}

#endif /* _GEOGRAPHICLAYER_H_ */
/*! @} */
